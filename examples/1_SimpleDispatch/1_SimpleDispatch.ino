/*
  format UTF-8

    Данный пример демонстрирует простое использование класса millisDispatch_t 
  для управления вызовом пользовательских функций через указанный промежуток 
  времени.
*/

#include <millis_dispatch.h>

const char *str = "This is user Task_";

/* 
    При объявлении экземпляра класса необходимо указать 
  параметр шаблона типа uint8_t, который задает максимально 
  возможное кличество регистрируемых в диспетчере функций.
  В данном примере этот параметр = 3, т.е. в диспетчере можно 
  зарегистрировать не более 3-х функций. 
*/
millisDispatch_t <3> simpleDispatch;

/* 
    Следующие функции: Task_1, Task_2, Task_3 - простые задачи, 
  в которых должен исполняться пользовательский код.
  Внимание!!! Все регистрируемые пользовательские функции должны быть
  следующей сигнатуры: 
    void Имя_Функции(void) {} 
*/

void Task_1(void) {
    Serial.print(str);
    Serial.println('1');
}

void Task_2(void) {
    Serial.print(str);
    Serial.println('2');
}

void Task_3(void) {
    static uint32_t counter = 0;
    Serial.print(str);
    Serial.print('3');
    Serial.print(" : counter = ");
    Serial.println(counter++);
}



void setup() {
    Serial.begin(9600);

    /* 
        Метот AddTask регистрирует пользовательскую задачу, 
      которая будет выполнятся с заданным периодом.

      Первый аргумент - указатель на функцию (имя функции), которую 
        необходимо вызвать (Функция должна иметь сигнатуру описанную выше)

      Второй аргумент - период выполнения регистрируемой функции в ms
        Допускается установка значения периода = 0, тогда функция будет 
        вызываться каждую итерацию метода Dispatch()
    */
    simpleDispatch.AddTask(Task_1, 1200);
    simpleDispatch.AddTask(Task_2, 3333);
    simpleDispatch.AddTask(Task_3, 600 );
}

void loop() {
    /* 
        Выполнение одной итерации диспетчеризации.
      Данный метод проходит по списку зарегистрированных функций,
      если время периода истекло диспетчер вызовет эту функцию.
     */
    simpleDispatch.Dispatch();
}