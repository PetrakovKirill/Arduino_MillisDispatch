/*
  format UTF-8

        Пример демонстрации использования класса millisDispatch_t для
    организации отложенного вызова функции обработки внешнего прерывания.

        Обработчик прерывания должен выполняться быстро, чтобы система могла 
    вовремя реагировать на другие асинхронные события. Код, который необходимо 
    выполнить по прерыванию не всегда выполняется быстро (например операции вывода).
    Логично подобный код выполнить в основном потке вне обработчика прерывания.
    Большинство решило бы эту задачу при помощи флагов и нагромождения блоков if в
    основном цикле. В этом примере раскрывается алтернативный подход к решению данной
    проблемы.

        При вызове основного обаботчика необходимо только зарегистрировать функцию 
    отложенного обработчика, вызов которой выполнит дисптечер уже в основном цикле 
    программы. Функция отложенной обработки прерывания должна удалить себя из списка 
    диспетчеризации, если она не должна быть повторно вызвана при следующей итерации
    диспечеризации.
*/

#include <millis_dispatch.h>

/* 
    При объявлении экземпляра класса необходимо указать 
  параметр шаблона типа uint8_t, который задает максимально 
  возможное кличество регистрируемых в диспетчере функций.
  В данном примере этот параметр = 3, т.е. в диспетчере можно 
  зарегистрировать не более 3-х функций. 
*/
millisDispatch_t <3> simpleDispatch;


/**
 * Основной цикл выполняющийся с периодом 500 ms просто 
 * печатает свое имя и текущее значение внутреннего счетчика.
*/
void MainTask(void) {
    static uint32_t counter = 0;
    Serial.print(__FUNCTION__);
    Serial.print(" : counter = ");
    Serial.println(counter++);
}


/**
 * Процедура отложенного вызова, которая уведомляет о 
 * срабатывании прерывания
*/
void DefferedInterruptHandler(void) {
    static uint32_t counter = 0;

    /* Проверка изменения состояния пина */
    if (digitalRead(2) != LOW) {
        /* 
            Если состояние изменилось, необходимо выйти из функции, 
           но перед этим необходимо удалить отложенный обработчик из 
           диспетчера.
           PS: goto использован умышленно, чтобы последовательно
           разобрать логику построения примера. 
        */
        goto just_exit;
    }

    Serial.print("Ext Interrupt Counter = ");
    Serial.println(counter++);

just_exit:
    /* Так как необходимо выполнить процедуру 1 раз
       удаляем процедуру из списка диспетчиризации */
    simpleDispatch.RemoveTask(DefferedInterruptHandler);
}


/**
 * Основной обработчик внешего прерывания
 */
void InterruptHandler(void) {
    /* Регистрируем отложенный обработчик, для подавления
       дребезга заложим задержку в 50 ms */
    simpleDispatch.AddTask(DefferedInterruptHandler, 50);
}


void setup() {
    Serial.begin(9600);

    /* 
      Настраиваем INT0, для предотвращения влияния наводок
      необходимо выполнить внутреннюю подтяжку.
     */
    pinMode(2, INPUT_PULLUP);

    /* 
        Регистрируем в диспетчере процедуру основного цикла, 
    с периодом выполнения = 500 ms.
    */
    simpleDispatch.AddTask(MainTask, 500);

    /* 
      Регистрируем обработчик прерывания Arduino
      для INT0 по спаду сигнала.
     */
    attachInterrupt(0, InterruptHandler, FALLING);
}

void loop() {
    /* 
        Выполнение одной итерации диспетчеризации.
      Данный метод проходит по списку зарегистрированных функций,
      если время периода истекло диспетчер вызовет эту функцию.
     */
    simpleDispatch.Dispatch();
}